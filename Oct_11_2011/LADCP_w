#!/usr/bin/perl
#======================================================================
#                    L A D C P _ W 
#                    doc: Fri Dec 17 18:11:13 2010
#                    dlm: Tue Oct 11 14:11:31 2011
#                    (c) 2010 A.M. Thurnherr
#                    uE-Info: 539 148 NIL 0 29 72 2 2 4 NIL ofnI
#======================================================================

# TODO:
#	- move (some? most? all?) data editing after profile begin/end
#	  detection so that editing stats make sense
#	- make timelagging work for short casts (make sure 10% is not more than half window size)
#	- own seabed detection (P403)
#	- make upcast-flag valid for yoyo casts
#	- make diagnostic output 3-beam field work for Earth coordinates
#	- remove water-depth from BT code, which is not really used and a bit of an outlier
#	  because mean and stddev are used instead of median/mad
#	? use instrument tilt in sidelobe editing?
#	? remove profile-binning code but add option to output BT-referenced data
#	? read assumed ADCP soundspeed from data file, instead of assuming 1500m/s

$antsSummary = 'calculate vertical velocities from LADCP & CTD time series';

# HISTORY:
#	Dec 17, 2010: - created from [mergeCTD+LADCP]
#	Dec 18, 2010: - made to work
#	Dec 19, 2010: - improved considerably
#	Dec 20, 2010: - onward
#				  - BUG: depth-binning was off by 1 bin?!
#				  - added binning correction for instrument tilt
#	Dec 21, 2010: - added -h (seafloor depth)
#	Dec 22, 2010: - BUG: had not applied soundspeed-correction to w
#				  - debugged opt_d
#	Dec 23, 2010: - continued implementation of soundspeed corrections
#	Dec 24, 2010: - added winch_w, wave_w
#				  - removed beampair velocities from code
#	Dec 25, 2010: - adapted for surface-wave correction in terms of acceleration (CTD_w_t)
#				  - removed elapsed_mismatch
#				  - removed winch_w, wave_w
#	Dec 26, 2010: - made -p output layout independent of -x to avoid Makefile problems
#	Dec 30, 2010: - cleaned up some
#				  - folded-in backscatter calculation from shear method
#				  - folded-in BT calculation from shear method
#	Dec 31, 2010: - added weighted mean w profile to output
#	Jan  2, 2010: - BUG: BT_w.mad could bomb with division by 0
#				  - BUG: division by zero if no valid data
#	Jan  5, 2010: - adapted to allow for gaps in CTD time series
#	Feb 16, 2011: - cosmetics
#	Jun 22, 2011: - cosmetics
#	Jun 23, 2011: - disabled error on large rms reflr w
#				  - added -l
#				  - removed CTD headers from output
#	Jun 26, 2011: - added -u
#				  - changed package correction from acceleration to velocity, because of
#					Stan's Antarctic data set where accelerations are zero but package effects are
#					there
#	Jul  2, 2011: - increased tilt default to 15 degrees
#	Jul  3, 2011: - replaced old package-velocity correction -x code by new beamvel correction
#				  - removed -p
#				  - replaced -d by residual (diagnostics) output
#	Jul  4, 2011: - saved a snapshot in [Jul_04_2011]
#				  - removed output of binned profile (but not calculation code, which is required for residual)
#				  - BUG: firstGoodEns or lastGoodEns could end up in a reflr_w gap when valid LADCP data begin
#						 or end with CTD in water
#				  - moved rarely used option -s to -k
#				  - added -s)kip <ens> option
#				  - had to very very slightly relax an assertion (by 1e-10 seconds...)
#	Aug  3, 2011: - added -z)ap to truncate range, based on Stan's 2009 data set (017-019 most clearly)
#				    obs that final 2 velocities are outliers; could be due to color bar, should check with
#					residuals
#	Sep 22, 2011: - removed (commented out) CTD acceleration
#				  - added basename to Parameter File Matching
#	Sep 23, 2011: - cosmetics (lots)
#				  - added -d)
#	Oct  6, 2011: - removed old commented-out code (CTD acceleration & old -x)
#				  - renamed time-series field names
#				  - added uncorrected reflr w to time-series output
#	Oct 10, 2011: - BUG: LADCP_w in .tds output had not been soundspeed corrected
#				  - removed -x
#				  - added "false-positives" editing filter

# PROCESSING PARAMETER FILE
#	- # is comment character
#	- invalid entries ignored
# 	- valid entries begin with <ADCP-basename|-filename>: (NO INITIAL SPACE ALLOWED)
#	- remainder of line is added to usage before ADCP file and LADCP_w is restarted
#	- no argument with spaces allowed!
#	- -0 suppresses acting on -l

# CTD REQUIREMENTS
#	- elapsed		elapsed seconds; see note below
#	- depth
#	- ss			sound speed
#	- w				ddepth/dt
#	- temp			OPTIONAL; used for backscatter calculation (i.e. not very important)

# NUMERICAL OPTIONS
#	- the first option in the list cannot be numerical!
#	- if need be, use -v 1 as a dummy option

# ELAPSED TIMES
#	- there are 2 different elapsed times used in this program:
#		1) elapsed based on firstgoodens in the LADCP time series
#		2) CTD elapsed time
#	- CTD elapsed time does not have to start with zero!
#	- do not use the Seabird elapsed field, which is only reported to
#	  3 significant digits, causing significant jitter in dt; however,
#	  at least up to 2010 Seabird simply calculates elapsed time by 
#	  assuming a 24Hz sampling rate and no record drop; therefore,
#	  it is best to calculate elapsed time as %RECNO/24
#	- the elapsed field of the output is the elapsed time from the CTD
#	  file; this is required in order to be able to compare the times
#	  from the uplooker and downlooker-derived vertical velocity
#	  profiles
#	- as a result, a profile only starts with elapsed==0 if the CTD
#	  is turned on when the LADCP is already in the water

# OUTPUT
#	- default is "long" output with all the data; required to generate Visbeck-type plots
#	- residuals are calculated with respect to down-/upcast medians in binned profiles
#	- -p requests old profile output
#	- BT-referenced profiles are only found in -p output
#	- equivalence, assuming -o 10:
#		1) 004DL.prof dc_w depth
#		2) bindata -Sdowncast:1 -Fw.median,depth -n 20 depth 0 1000 10 004DL.w

# TIME LAGGING
#	- occasionally, the time lagging algorithm fails, in particular if the CTD is turned on
#	  some time after the package enters the water
#	- in this case, an initial guess can be provided with -i
#	- e.g. plot 'CTD/24Hz/054.1Hz elapsed w','LADCP/raw/054UL.prof =$elapsed-850 w' => -i -850

# VELOCITY AMBIGUITY ERRORS
#	- quite extensive tests with DIMES US2 station 146, which has a lot of
#	  ambiguity velocity errors, reveal that -m 1 catches those errors
#	  quite nicely
#	- even when the errors are not filtered with -m 1, they do not
#	  affect the w profiles, as long as the median bin values are used

# SCREEN LOGGING
#	- there are 4 verbosity levels, selected by -v
#		0:	only print errors
#		1:	default, UNIX-like (warnings and info messages that are not produced for every cast)
#		2:	progress messages and useful information
#		>2:	debug messges
#	- the most useful ones of these are 1 & 2

($WCALC) 	  = ($0                =~ m{^(.*)/[^/]*$});
($ANTS) 	  = (`which list`      =~ m{^(.*)/[^/]*$});
($PERL_TOOLS) = (`which mkProfile` =~ m{^(.*)/[^/]*$});

require "$ANTS/ants.pl";
require "$ANTS/libstats.pl";
require "$WCALC/edit_data.pl";
require "$WCALC/time_series.pl";
require "$WCALC/time_lag.pl";
require "$WCALC/find_seabed.pl";
require "$WCALC/svel_corrections.pl";
require "$WCALC/acoustic_backscatter.pl";
require "$WCALC/bottom_tracking.pl";
require "$PERL_TOOLS/RDI_BB_Read.pl";
require "$PERL_TOOLS/RDI_Coords.pl";

@ARGS = @ARGV;														# save opts & arguments

$antsParseHeader = 0;
&antsUsage('03:4a:b:c:d:e:f:g:h:i:k:l:m:n:o:p:r:s:t:uv:w:z:',1,
	'[-l)oad processing parameters from <file>]',
	'[-v)erbosity <level[1]>]',
    '[require -4)-beam solutions] [-d)iscard vels from <beam>]',
	'[-r)ef-layer <bin[2],bin[6]>]',
	'[-c)orrelation <min[70]>] [-t)ilt <max[10deg]> [-e)rr-vel <max[0.1m/s]>]',
	'[-z)ap (truncate) range by <n> bins]',
	'[-h water <depth>]',
	'[max LADCP time-series -g)ap <length[60s]>]',
	'[-m)ax vertical <velocity[1m/s]>',
	'[-a)djust CTD depth <by[0m]>]',
	'[-i)nitial CTD time offset <guestimate> [-u)se as final]]',
	'[calculate -n) <lags,lags[10,100]>] [lag -w)indow <sz,sz[240s,20s]>]',
	'[require top-3) lags to account for <frac[0.6]> of all]',
	'[valid LADCP -b)ins <bin[2],bin[*]>',
	'[-o)utput bin <resolution[50m]>] [-k) require <min[20]> samples]',
	'[-f) write time-series <file>] [output binned -p)rofile to <file>]',
	'<LADCP-file> [CTD-file]');

&antsCardOpt(\$opt_v,1);											# suppress regular info

$RDI_Coords::minValidVels = 4 if ($opt_4);							# suppress 3-beam solutions
&antsCardOpt($opt_d);
croak("$0: -d must be in the range 1-4, not $opt_d\n")
	if defined($opt_d) && ($opt_d<1 || $opt_d>4);

&antsFloatOpt(\$opt_c,70);											# min correlation
&antsFloatOpt(\$opt_t,15);											# max tilt (pitch/roll)
&antsFloatOpt(\$opt_e,0.1);											# max err vel
&antsFloatOpt(\$opt_z,0);											# truncate final valid velocities
&antsFloatOpt(\$opt_g,60);											# max LADCP gap length
&antsFloatOpt(\$opt_m,1);											# max allowed vertical velocity

&antsFloatOpt(\$opt_a,0);											# CTD depth adjustment

&antsFloatOpt($opt_i);												# externally supplied lag
&antsUsageError() if ($opt_u && !defined($opt_i));

&antsCardOpt(\$opt_s,0);											# skip # initial ensembles

$opt_n = '10,100' unless defined($opt_n);							# number of time lags to carry out
$opt_w = '240,20' unless defined($opt_w);							# time lag search window (full width)
&antsFloatOpt(\$opt_3,0.6);

&antsFloatOpt(\$opt_o,50);											# output bin size
&antsCardOpt(\$opt_k,20);											# min samples required

$opt_r = '2,6' unless defined($opt_r);								# reference layer bins for w for time matching
$opt_b = '2,*' unless defined($opt_b);								# bins to use in w calculations

@n_lags = split(',',$opt_n);										# decode -n
croak("$0: cannot decode -n $opt_n\n")
	unless numberp($n_lags[0]) && numberp($n_lags[1]);

@w_size = split(',',$opt_w);										# decode -w
croak("$0: cannot decode -w $opt_w\n")
	unless numberp($w_size[0]) && numberp($w_size[1]);

($refLr_firstBin,$refLr_lastBin) = split(',',$opt_r);				# decode -r
croak("$0: cannot decode -r $opt_r\n")
	unless numberp($refLr_firstBin) && numberp($refLr_lastBin);

($LADCP_firstBin,$LADCP_lastBin) = split(',',$opt_b);				# decode -b
croak("$0: cannot decode -b $opt_b\n")
	unless (numberp($LADCP_firstBin) &&
			($LADCP_lastBin eq '*' || numberp($LADCP_lastBin)));

$LADCP_file = &antsFileArg();
($LADCP_basename) = ($LADCP_file =~ m{^.*/([^/]*)$});

if (defined($opt_l) && !defined($opt_0)) {							# load per-cast processing parameters
	my(@cast_params);
	open(PF,$opt_l) || croak("$opt_l: $!\n");
	while (<PF>) {
		s/#.*//;
		@cast_params=split(/\s+/),last if /^$LADCP_basename:/ || /^$LADCP_filename:/;
	}
	close(PF);

	if (@cast_params) {												# found valid entry
		if ($ARGS[$#ARGS] eq $LADCP_file) {							# CTD data on <stdin>
			exec($0,@ARGS[0..$#ARGS-1],@cast_params[1..$#cast_params],'-0',$ARGS[$#ARGS]);
			die("exec($0,@ARGS[0..$#ARGS-1],@cast_params[1..$#cast_params],'-0',$ARGS[$#ARGS]) failed!\n");
    	} else {													# CTD file specified on cmdline
			exec($0,@ARGS[0..$#ARGS-2],@cast_params[1..$#cast_params],'-0',$LADCP_file,$ARGS[$#ARGS]);
			die("exec($0,@ARGS[0..$#ARGS-2],@cast_params[1..$#cast_params],'-0',$LADCP_file,$ARGS[$#ARGS]) failed!\n");
    	}
    }
}

#----------------------------------------------------------------------
# Screen Logging
#	- warning levels:
#		0 probably unimportant, e.g. nonsensical parameters that probably won't affect solution
#		1 may be somewhat important
#		2 important
#----------------------------------------------------------------------

sub progress(@)
{  printf(STDERR @_) if ($opt_v > 1); }

sub info(@)
{
	print(STDERR ($opt_v > 1) ? "\t" : "$LADCP_file: ");
	printf(STDERR @_)  if ($opt_v > 0);
}
	
sub warning(@)
{
	my($lvl,@msg) = @_;
	return if ($opt_v == 0);
	print(STDERR "\n") if ($opt_v > 1);
	print(STDERR "WARNING (level $lvl): ");
	printf(STDERR @msg);
	print(STDERR "\n") if ($opt_v > 1);
}

sub debugmsg(@)
{ printf(STDERR @_) if ($opt_v > 2); }

#----------------
# Read LADCP data
#----------------

progress("Reading LADCP data ($LADCP_file)...\n");
readData($LADCP_file,\%LADCP);
progress("\t%d ensembles\n",scalar(@{$LADCP{ENSEMBLE}}));

croak("$LADCP_file: not enough LADCP bins ($LADCP{N_BINS}) for choice of -r\n")
	unless ($LADCP{N_BINS} >= $refLr_lastBin);

croak("$0: first reference-layer bin outside valid range\n")
	unless ($refLr_firstBin>=1 && $refLr_firstBin<=$LADCP{N_BINS});
croak("$0: last reference-layer bin outside valid range\n")
	unless ($refLr_lastBin>=1 && $refLr_lastBin<=$LADCP{N_BINS});
croak("$0: first reference-layer bin > last reference-layer bin\n")
	unless ($refLr_firstBin <= $refLr_lastBin);

$LADCP_lastBin = $LADCP{N_BINS}-1
	if ($LADCP_lastBin eq '*');
croak("$0: first valid LADCP bin outside valid range\n")
	unless ($LADCP_firstBin>=1 && $LADCP_firstBin<=$LADCP{N_BINS});
croak("$0: last valid LADCP bin outside valid range\n")
	unless ($LADCP_lastBin>=1 && $LADCP_lastBin<=$LADCP{N_BINS});
croak("$0: first valid LADCP bin > last valid LADCP bin\n")
	unless ($LADCP_firstBin <= $LADCP_lastBin);

warning(0,"first reference-layer bin < first valid LADCP bin\n")
	unless ($refLr_firstBin >= $LADCP_firstBin);
warning(0,"last reference-layer bin > last valid LADCP bin\n")
	unless ($refLr_lastBin <= $LADCP_lastBin);

warning(1,"if at all, bin 1 should not be used for short blank-after-transmit values\n")
	if ($LADCP{BLANKING_DISTANCE}<$LADCP{BIN_LENGTH} && $refLr_firstBin==1);

#------------------------------------------------------------
# Edit beam-velocity data
#	1) correlation threshold
#	2) tilt threshold (also sets TILT field in all ensembles)
#------------------------------------------------------------

if ($LADCP{BEAM_COORDINATES}) {
	progress("Editing beam-velocity data...\n");
	$nvv = $cte = 0;
	for ($ens=0; $ens<=$#{$LADCP{ENSEMBLE}}; $ens++) {
		$nvv += countValidBeamVels($ens);
		$cte += editCorr($ens,$opt_c);
		$pte += editTilt($ens,$opt_t);
	}
	croak("$LADCP_file: no valid data\n") unless ($nvv > 0);
	progress("\tcorrelation threshold (-c %d counts): %d velocites removed (%d%% of total)\n",$opt_c,$cte,round(100*$cte/$nvv));
	progress("\tattitude threshold (-t %d deg): %d velocites removed (%d%% of total)\n",$opt_t,$pte,round(100*$pte/$nvv));
} else {
	progress("Editing velocity data...\n");
	$nvv = $cte = 0;
	for ($ens=0; $ens<=$#{$LADCP{ENSEMBLE}}; $ens++) {
		$nvv += countValidBeamVels($ens);
		$cte += editCorr_Earthcoords($ens,$opt_c);
		$pte += editTilt($ens,$opt_t);
	}
	croak("$LADCP_file: no valid data\n") unless ($nvv > 0);
	progress("\tcorrelation threshold (-c %d counts): %d velocites removed (%d%% of total)\n",$opt_c,$cte,round(100*$cte/$nvv));
	progress("\tattitude threshold (-t %d deg): %d velocites removed (%d%% of total)\n",$opt_t,$pte,round(100*$pte/$nvv));
}

#-------------------------------------------------------------------
# Calculate earth velocities
#	- this is done for all bins (not just valid ones), to allow
#	  useless possibility that invalid bins are used for reflr calcs
#	- also calculate separate beam-pair velocities
#	- the UNEDITED velocities are saved for the BT calculations
#	  (W is required, U & V are only used for stats that have not
#	  been very useful so far)
#-------------------------------------------------------------------

if ($LADCP{BEAM_COORDINATES}) {
	progress("Calculating earth-coordinate velocities...\n");
	progress("\tdiscarding velocities from beam $opt_d\n")
		if defined($opt_d);
	$nvw = 0;
	for ($ens=0; $ens<=$#{$LADCP{ENSEMBLE}}; $ens++) {
		for (my($bin)=$LADCP_firstBin-1; $bin<=$LADCP_lastBin-1; $bin++) {
			undef($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][$opt_d-1])
				if defined($opt_d);
			($LADCP{ENSEMBLE}[$ens]->{U}[$bin],
			 $LADCP{ENSEMBLE}[$ens]->{V}[$bin],
			 $LADCP{ENSEMBLE}[$ens]->{W}[$bin],
			 $LADCP{ENSEMBLE}[$ens]->{ERRVEL}[$bin]) =
				velInstrumentToEarth(\%LADCP,$ens,
					velBeamToInstrument(\%LADCP,
										@{$LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin]}));
			$nvw += defined($LADCP{ENSEMBLE}[$ens]->{W}[$bin]);
			$LADCP{ENSEMBLE}[$ens]->{GIMBAL_PITCH} =
			 	gimbal_pitch($LADCP{ENSEMBLE}[$ens]->{PITCH},$LADCP{ENSEMBLE}[$ens]->{ROLL});
			$LADCP{ENSEMBLE}[$ens]->{U_UNEDITED}[$bin] = $LADCP{ENSEMBLE}[$ens]->{U}[$bin];
			$LADCP{ENSEMBLE}[$ens]->{V_UNEDITED}[$bin] = $LADCP{ENSEMBLE}[$ens]->{V}[$bin];
			$LADCP{ENSEMBLE}[$ens]->{W_UNEDITED}[$bin] = $LADCP{ENSEMBLE}[$ens]->{W}[$bin];
		}
	}
	progress("\t$nvw valid velocities in bins $LADCP_firstBin-$LADCP_lastBin\n");
	progress("\t3-beam solutions : $RDI_Coords::threeBeam_1 " .
								  "$RDI_Coords::threeBeam_2 " .
								  "$RDI_Coords::threeBeam_3 " .
								  "$RDI_Coords::threeBeam_4\n")
	    unless ($opt_4);
} else {
	progress("Counting valid vertical velocities...\n");
	$nvw = 0;
	for ($ens=0; $ens<=$#{$LADCP{ENSEMBLE}}; $ens++) {
		for (my($bin)=$LADCP_firstBin-1; $bin<=$LADCP_lastBin-1; $bin++) {
			($LADCP{ENSEMBLE}[$ens]->{U}[$bin],
			 $LADCP{ENSEMBLE}[$ens]->{V}[$bin],
			 $LADCP{ENSEMBLE}[$ens]->{W}[$bin],
			 $LADCP{ENSEMBLE}[$ens]->{ERRVEL}[$bin]) = @{$LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin]};
			$nvw += defined($LADCP{ENSEMBLE}[$ens]->{W}[$bin]);
			$LADCP{ENSEMBLE}[$ens]->{U_UNEDITED}[$bin] = $LADCP{ENSEMBLE}[$ens]->{U}[$bin];
			$LADCP{ENSEMBLE}[$ens]->{V_UNEDITED}[$bin] = $LADCP{ENSEMBLE}[$ens]->{V}[$bin];
			$LADCP{ENSEMBLE}[$ens]->{W_UNEDITED}[$bin] = $LADCP{ENSEMBLE}[$ens]->{W}[$bin];
		}
	}
	progress("\t$nvw valid velocities in bins $LADCP_firstBin-$LADCP_lastBin\n");
}

croak("$LADCP_file: insufficient valid velocities\n") unless ($nvw > 1000);

#----------------------------------------------
# S1 STEP: Edit earth-coordinate -velocity data
#	1) error-velocity threshold
#----------------------------------------------

progress("Editing earth-coordinate velocity data...\n");

$ete = $zte = $fpte = 0;
for ($ens=0; $ens<=$#{$LADCP{ENSEMBLE}}; $ens++) {
	$ete  += editErrVel($ens,$opt_e);
	$fpte += editFalsePositives($ens);
	$zte  += editTruncRange($ens,$opt_z) if ($opt_z > 0);
}
progress("\terror-velocity threshold (-e %.1f m/s): %d velocites removed (%d%% of total in bins $LADCP_firstBin-$LADCP_lastBin)\n",
	$opt_e,$ete,round(100*$ete/$nvw));
progress("\t\"false-positives\" filter: %d velocites removed (%d%% of total in bins $LADCP_firstBin-$LADCP_lastBin)\n",
	$fpte,round(100*$fpte/$nvw));
progress("\trange truncation (-z %d bins): %d velocites removed (%d%% of total in bins $LADCP_firstBin-$LADCP_lastBin)\n",
	$opt_z,$zte,round(100*$zte/$nvw))
		if ($opt_z > 0);

#----------------------------
# Calculate LADCP time series
#----------------------------

progress("Calculating LADCP time-series...\n");

($firstGoodEns,$lastGoodEns,$LADCP_atbottom,$LADCP_w_gap_time) =
	calcLADCPts(\%LADCP,$opt_s,$refLr_firstBin,$refLr_lastBin,$opt_g);
croak("$LADCP_file: no good ensembles\n")
	unless defined($firstGoodEns) && ($lastGoodEns-$firstGoodEns > 0);

my($cast_duration) = $LADCP{ENSEMBLE}[$lastGoodEns]->{ELAPSED} -
				     $LADCP{ENSEMBLE}[$firstGoodEns]->{ELAPSED};
croak("$0: implausibly short cast ($cast_duration seconds)\n")
	unless ($cast_duration > 600);

$LADCP{MEAN_DT} = $cast_duration / ($lastGoodEns-$firstGoodEns-1);

progress("\tStart of cast     : %s (#%5d)\n",
					$LADCP{ENSEMBLE}[$firstGoodEns]->{TIME},
					$LADCP{ENSEMBLE}[$firstGoodEns]->{NUMBER});
progress("\tBottom of cast    : %s (#%5d) @ dz=%6dm\n",
					$LADCP{ENSEMBLE}[$LADCP_atbottom]->{TIME},
					$LADCP{ENSEMBLE}[$LADCP_atbottom]->{NUMBER},
					$LADCP{ENSEMBLE}[$LADCP_atbottom]->{DEPTH});
progress("\tEnd of cast       : %s (#%5d) @ dz=%6dm\n",
					$LADCP{ENSEMBLE}[$lastGoodEns]->{TIME},
					$LADCP{ENSEMBLE}[$lastGoodEns]->{NUMBER},
					$LADCP{ENSEMBLE}[$lastGoodEns]->{DEPTH});
progress("\tCast duration     : %.1f hours (pinging for %.1f hours)\n",
					$cast_duration / 3600,
					($LADCP{ENSEMBLE}[$#{$LADCP{ENSEMBLE}}]->{UNIX_TIME} -
						$LADCP{ENSEMBLE}[0]->{UNIX_TIME}) / 3600);
progress("\tMean ping interval: %.1f seconds\n",$LADCP{MEAN_DT});

#--------------
# Read CTD data
#--------------

progress("Reading CTD data...\n");
croak("$0: no CTD data\n") unless (&antsIn());
undef($antsOldHeaders);
($CTD_elapsed,$CTD_depth,$CTD_svel,$CTD_w) = &fnr('elapsed','depth','ss','w');
$CTD_temp = &fnrNoErr('temp');

$CTD_maxdepth = -1;

do {
	croak("$0: cannot deal with non-numeric CTD elapsed time\n")
		unless &antsNumbers($CTD_elapsed);
	push(@{$CTD{ELAPSED}},$ants_[0][$CTD_elapsed]);
	push(@{$CTD{DEPTH}},  $ants_[0][$CTD_depth]+$opt_a);
	push(@{$CTD{SVEL}},   $ants_[0][$CTD_svel]);
	push(@{$CTD{W}},      $ants_[0][$CTD_w]);
	push(@{$CTD{TEMP}},	  $ants_[0][$CTD_temp]) if defined($CTD_temp);
	if ($ants_[0][$CTD_depth]+$opt_a > $CTD_maxdepth) {
		$CTD_maxdepth = $ants_[0][$CTD_depth]+$opt_a;
		$CTD_atbottom = $#{$CTD{DEPTH}};
	}
} while (&antsIn());

$CTD{DT} = ($CTD{ELAPSED}[$#{$CTD{ELAPSED}}] - $CTD{ELAPSED}[0]) / $#{$CTD{ELAPSED}};

progress("\t%d scans at %.1fHz\n",scalar(@{$CTD{DEPTH}}),1/$CTD{DT});
progress("\tstart depth = %.1fm\n",$CTD{DEPTH}[0]);
croak("$0: CTD start depth must be numeric\n")
	unless numberp($CTD{DEPTH}[0]);
progress("\tmax depth   = %dm (# $CTD_atbottom)\n",$CTD_maxdepth);

#--------------------------------------------------------------------
# Construct sound-speed correction profile from CTD 1Hz downcast data
#	very simple algorithm that stores the last value found
#	in each 1m bin
#--------------------------------------------------------------------

progress("Constructing sound-speed correction profile\n");

my($scans_per_sec) = int(1/$CTD{DT}+0.5);
for (my($s)=0; $s<=$CTD_atbottom; $s+=$scans_per_sec) {
	next unless ($CTD{DEPTH}[$s] >= 0 && numberp($CTD{SVEL}[$s]));
	$sVelProf[int($CTD{DEPTH}[$s])] = $CTD{SVEL}[$s];
}

#-------------------
# Determine time lag
#-------------------

if (defined($opt_i)) {
	progress("Setting initial time lag...\n");
	$CTD{TIME_LAG} = $opt_i;
	progress("\t-i => elapsed(CTD) ~ elapsed(LADCP) + %.1fs\n",$CTD{TIME_LAG});
} else {
	progress("Guestimating time lag...\n");
	
	my($CTD_10pct_down) = 0;
	my($LADCP_10pct_down) = $firstGoodEns;

	$CTD_10pct_down++
		until ($CTD{DEPTH}[$CTD_10pct_down]-$CTD{DEPTH}[0] >= 0.1*($CTD_maxdepth-$CTD{DEPTH}[0]));
	$LADCP_10pct_down++
		until ($LADCP{ENSEMBLE}[$LADCP_10pct_down]->{DEPTH} >= 0.1*$LADCP{ENSEMBLE}[$LADCP_atbottom]->{DEPTH});

	$CTD{TIME_LAG} =
		$CTD{ELAPSED}[$CTD_10pct_down] - $LADCP{ENSEMBLE}[$LADCP_10pct_down]->{ELAPSED};

	print(STDERR "$CTD{DEPTH}[$CTD_10pct_down]-$CTD{DEPTH}[0],  $CTD{ELAPSED}[$CTD_10pct_down],  $LADCP{ENSEMBLE}[$LADCP_10pct_down]->{ELAPSED}\n");
	
	progress("\telapsed(dz(CTD)=%.1fm) ~ elapsed(dz(LADCP)=%.1fm) + %.1fs\n",
	    $CTD{DEPTH}[$CTD_10pct_down]-$CTD{DEPTH}[0],$LADCP{ENSEMBLE}[$LADCP_10pct_down]->{DEPTH},$CTD{TIME_LAG});
}

if ($opt_u) {
	progress("\tskipping time lagging (-u)\n");
} else {
	$CTD{TIME_LAG} = calc_lag($n_lags[0],$w_size[0],int(1/$CTD{DT}+0.5));
	progress("\telapsed(CTD) ~ elapsed(LADCP) + %.2fs\n",$CTD{TIME_LAG});
	
	$CTD{TIME_LAG} = calc_lag($n_lags[1],$w_size[1],1);
	progress("\telapsed(CTD) = elapsed(LADCP) + %.2fs\n",$CTD{TIME_LAG});
}

&antsAddParams('CTD_time_lag',$CTD{TIME_LAG});

#------------------------------------------------
# Merge CTD with LADCP data
#	- after this step, reflr w is sound-speed corrected!!!
#------------------------------------------------

progress("Merging CTD with LADCP data...\n");

for (my($skipped)=0,my($ens)=$firstGoodEns; $ens<=$lastGoodEns; $ens++) {
	my($scan) = int(($LADCP{ENSEMBLE}[$ens]->{ELAPSED} + $CTD{TIME_LAG} - $CTD{ELAPSED}[0]) / $CTD{DT} + 0.5);
	if ($scan <= 0) {	# NB: must be <=, rather than <, or assertion below sometimes fails
		$skipped++;
		$firstGoodEns = $ens+1;
		next;
	}
	if ($skipped > 0) {
		$firstGoodEns++,$skipped++,next									# in gap
			unless defined($LADCP{ENSEMBLE}[$firstGoodEns]->{REFLR_W});
		info("$skipped initial LADCP ensembles skipped because CTD data begin with LADCP in water\n");
		$skipped = 0;
	}
	if ($scan > $#{$CTD{ELAPSED}}) {
		while (!defined($LADCP{ENSEMBLE}[$ens-1]->{REFLR_W})) { $ens--; }	# in gap
		info(sprintf("%d final LADCP ensembles skipped because CTD data end with LADCP in water\n",
			$lastGoodEns-$ens+1));
		$lastGoodEns = $ens-1;
		last;
	}

	die("assertion failed!\n" .
		"\ttest: abs($LADCP{ENSEMBLE}[$ens]->{ELAPSED} + $CTD{TIME_LAG} - $CTD{ELAPSED}[$scan]) <= $CTD{DT}/2\n" .
		"\tens = $ens, scan = $scan\n" .
		sprintf("\tadjusted LADCP time = %f\n",$LADCP{ENSEMBLE}[$ens]->{ELAPSED} + $CTD{TIME_LAG}) .
		sprintf("\tCTD($scan) time = %f\n",$CTD{ELAPSED}[$scan]) .
		"=> Did you use SeaBird elapsed time? Don't!"
	) unless (abs($LADCP{ENSEMBLE}[$ens]->{ELAPSED} + $CTD{TIME_LAG} - $CTD{ELAPSED}[$scan]) <= $CTD{DT}/2 + 1e-10);

	$LADCP{ENSEMBLE}[$ens]->{CTD_ELAPSED} = $CTD{ELAPSED}[$scan];		# elapsed field for output

	if (defined($LADCP{ENSEMBLE}[$ens]->{REFLR_W})						# not a gap
			&& numberp($CTD{DEPTH}[$scan])) {
		$LADCP{ENSEMBLE}[$ens]->{REFLR_W_NOSSCORR} = $LADCP{ENSEMBLE}[$ens]->{REFLR_W};				
	    $LADCP{ENSEMBLE}[$ens]->{REFLR_W} *= $CTD{SVEL}[$scan]/1500; 	# correct for sound-speed variations at source
		croak(sprintf("\n$0: negative depth (%.1fm) in CTD file at elapsed(CTD) = %.1fs (use -a?)\n",
			$CTD{DEPTH}[$scan],$CTD{ELAPSED}[$scan]))
				unless ($CTD{DEPTH}[$scan] >= 0);
		$LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH} = $CTD{DEPTH}[$scan];
		$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN} = $scan;
		my($reflr_ocean_w) = $LADCP{ENSEMBLE}[$ens]->{REFLR_W} - $CTD{W}[$scan];
		if (abs($reflr_ocean_w) <= $opt_m) {
			$sumWsq += &SQR($reflr_ocean_w);
			$nWsq++;
			if ($LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH} > 100 &&
				$LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH} < $LADCP{ENSEMBLE}[$LADCP_atbottom]->{CTD_DEPTH}-100) {
					$sumWsqI += &SQR($reflr_ocean_w);
					$nWsqI++;
	        }
	    } else {
	    	undef($LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH});					# DON'T USE THIS ENSEMBLE LATER
	    }
	} else{
	    undef($LADCP{ENSEMBLE}[$ens]->{REFLR_W});						# don't output in time-series file
	    undef($LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH});						# old DEPTH from calcLADCPts()
	}
}
	
if ($nWsq > 0 && $nWsqI > 0) {
	&antsAddParams('rms_w_reflr_err',sqrt($sumWsq/$nWsq),'rms_w_reflr_err_interior',sqrt($sumWsqI/$nWsqI));
	progress("\t%.2f cm/s rms reference-layer w_ocean, %.2f cm/s away from boundaries\n",
						100*sqrt($sumWsq/$nWsq),100*sqrt($sumWsqI/$nWsqI));
	warning(0,"%.2f cm/s reference-layer w_ocean away from boundaries\n",100*sqrt($sumWsqI/$nWsqI))
		if (sqrt($sumWsqI/$nWsqI) > 0.05);
#	croak("$0: rms reference-layer w_ocean is too large\n")
#		unless (sqrt($sumWsqI/$nWsqI) < 0.07);
} elsif ($nWsq > 0) {
	&antsAddParams('rms_w_reflr_err',sqrt($sumWsq/$nWsq),'rms_w_reflr_err_interior',nan);
	progress("\t%.2f cm/s rms reference-layer w_ocean\n",100*sqrt($sumWsq/$nWsq));
} else {
	croak("$0: no valid vertical velocities\n");
}

#----------------------------------------------------------------------------
# Remove data contaminated by sidelobe reflection from seabed and sea surface
#----------------------------------------------------------------------------

if ($LADCP{ENSEMBLE}[$LADCP_atbottom]->{XDUCER_FACING_DOWN}) {
	&antsAddParams('ADCP_orientation','downlooker');

	if (numberp($opt_h)) {
		progress("Setting water depth (-h)\n");
		$water_depth = $opt_h;
		$sig_water_depth = 0;
	} else {
		progress("Finding seabed...\n");
		calc_backscatter_profs($firstGoodEns,$lastGoodEns);
		($water_depth,$sig_water_depth) =
			find_backscatter_seabed($LADCP{ENSEMBLE}[$LADCP_atbottom]->{CTD_DEPTH});
		($water_depth_BT,$sig_water_depth_BT) =
			find_seabed(\%LADCP,$LADCP_atbottom,$LADCP{BEAM_COORDINATES});
		if (defined($water_depth_BT)) {
			my($dd) = abs($water_depth_BT - $water_depth);
			warning(2,sprintf("Large RDI vs. own water-depth difference (%.1fm)\n",$dd))
				if ($dd > 5);
		}
	}
	
	&antsAddParams('water_depth',$water_depth,'water_depth.sig',$sig_water_depth);

	if (defined($water_depth)) {
		if (defined($water_depth_BT)) {
			progress("\t%.1f(%.1f) m water depth (%.1f(%.1f)m from BT)\n",
				$water_depth,$sig_water_depth,$water_depth_BT,$sig_water_depth_BT);
		} else {
			progress("\t%.1f(%.1f) m water depth\n",$water_depth,$sig_water_depth);
		}
		warning(1,sprintf("large uncertainty in water-depth estimation (%.1fm)\n",$sig_water_depth))
			if ($sig_water_depth > $LADCP{BIN_LENGTH});

		progress("Editing data to remove sidelobe interference from seabed...\n");
		($nvrm,$nerm) = editSideLobes($firstGoodEns,$lastGoodEns,$water_depth);
		progress("\t$nvrm velocities from $nerm ensembles removed\n");

	} else {
		info("no seabed found in backscatter profiles --- no sidelobe editing done\n");
	}
	
} else {
	&antsAddParams('ADCP_orientation','uplooker');
	progress("Editing data to remove sidelobe interference from sea surface...\n");
	($nvrm,$nerm) = editSideLobes($firstGoodEns,$lastGoodEns,undef);
	progress("\t$nvrm velocities from $nerm ensembles removed\n");
}

#---------------------------------------------------------------------------
# Depth-bin LADCP velocity data
#
# NOTES:
#	1) ensemble and bin numbers are saved for maximum flexibility
#	2) only ensemble/bins with valid vertical velocities are saved
#	3) applying the full soundspeed correction to w is most likely pointless in
#	   practice, but hey!, CPU cycles are cheap; [in a cast in the Gulf of Mexico
#	   which has fairly pronounce soundspeed gradients, the max value of Kn
#	   is 1.00004160558372, which gives rise to a correction of less than 0.2mm/s
#	   at a winch+wave speed of 3m/s....]
#	4) as far as I can tell, the soundspeed correction for bin length also
#	   has only a minute effect
#---------------------------------------------------------------------------

progress("Binning velocities...\n");

my($min_depth) = 9e99;
my($max_depth) = 0;

progress("\tdowncast...\n");
for ($ens=$firstGoodEns; $ens<$LADCP_atbottom; $ens++) {						# downcast
	next unless numberp($LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH});
	my(@bindepth) = calc_binDepths($ens);
	for ($bin=$LADCP_firstBin-1; $bin<=$LADCP_lastBin-1; $bin++) {
		next unless numberp($LADCP{ENSEMBLE}[$ens]->{W}[$bin]);
		$min_depth = $bindepth[$bin] if ($bindepth[$bin] < $min_depth);
		$max_depth = $bindepth[$bin] if ($bindepth[$bin] > $max_depth);
		$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin] =
			sscorr_w($LADCP{ENSEMBLE}[$ens]->{W}[$bin],
					 $CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
					 $LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH},
					 $bindepth[$bin]);
		$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_W}[$bin] =
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin] + $CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}];
		my($bi) = $bindepth[$bin]/$opt_o;
		push(@{$DNCAST{ENSEMBLE}[$bi]},$ens);
		push(@{$DNCAST{ELAPSED}[$bi]},$CTD{ELAPSED}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}]);
		push(@{$DNCAST{CTD_W}[$bi]},$CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}]);
		push(@{$DNCAST{BIN}[$bi]},$bin);
		push(@{$DNCAST{DEPTH}[$bi]},$bindepth[$bin]);
		push(@{$DNCAST{W}[$bi]},$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin]);
	}
}

for (my($bi)=0; $bi<=$#{$DNCAST{ENSEMBLE}}; $bi++) {							# bin data
	$DNCAST{MEAN_DEPTH}[$bi]  	= avg(@{$DNCAST{DEPTH}[$bi]});
	$DNCAST{MEAN_ELAPSED}[$bi]	= avg(@{$DNCAST{ELAPSED}[$bi]});
	$DNCAST{MEDIAN_W}[$bi] 	  	= median(@{$DNCAST{W}[$bi]});
	$DNCAST{MAD_W}[$bi]		  	= mad2($DNCAST{MEDIAN_W}[$bi],@{$DNCAST{W}[$bi]});
	$DNCAST{N_SAMP}[$bi]		= @{$DNCAST{W}[$bi]};
}


progress("\tupcast...\n");														# upcast

for ($ens=$LADCP_atbottom; $ens<=$lastGoodEns; $ens++) {		
	next unless numberp($LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH});
	my(@bindepth) = calc_binDepths($ens);
	for ($bin=$LADCP_firstBin-1; $bin<=$LADCP_lastBin-1; $bin++) {
		next unless numberp($LADCP{ENSEMBLE}[$ens]->{W}[$bin]);
		$min_depth = $bindepth[$bin] if ($bindepth[$bin] < $min_depth);
		$max_depth = $bindepth[$bin] if ($bindepth[$bin] > $max_depth);
		$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin] =
			sscorr_w($LADCP{ENSEMBLE}[$ens]->{W}[$bin],
					 $CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
					 $LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH},
					 $bindepth[$bin]);
		$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_W}[$bin] =
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin] + $CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}];
		my($bi) = $bindepth[$bin]/$opt_o;
		push(@{$UPCAST{ENSEMBLE}[$bi]},$ens);
		push(@{$UPCAST{ELAPSED}[$bi]},$CTD{ELAPSED}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}]);
		push(@{$UPCAST{CTD_W}[$bi]},$CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}]);
		push(@{$UPCAST{BIN}[$bi]},$bin);
		push(@{$UPCAST{DEPTH}[$bi]},$bindepth[$bin]);
		push(@{$UPCAST{W}[$bi]},$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin]);
	}
}

for (my($bi)=0; $bi<=$#{$UPCAST{ENSEMBLE}}; $bi++) {
	$UPCAST{MEAN_DEPTH}[$bi]  	= avg(@{$UPCAST{DEPTH}[$bi]});
	$UPCAST{MEAN_ELAPSED}[$bi]	= avg(@{$UPCAST{ELAPSED}[$bi]});
	$UPCAST{MEDIAN_W}[$bi] 	  	= median(@{$UPCAST{W}[$bi]});
	$UPCAST{MAD_W}[$bi]		  	= mad2($UPCAST{MEDIAN_W}[$bi],@{$UPCAST{W}[$bi]});
	$UPCAST{N_SAMP}[$bi]		= @{$UPCAST{W}[$bi]};
}

&antsAddParams('min_depth',$min_depth,'max_depth',$max_depth,
			   'min_elapsed',$LADCP{ENSEMBLE}[$firstGoodEns]->{CTD_ELAPSED},
			   'max_elapsed',$LADCP{ENSEMBLE}[$lastGoodEns]->{CTD_ELAPSED});

#--------------------------------------------------
# Calculate BT-referenced vertical-velocity profile
#--------------------------------------------------

if (defined($water_depth)) {
	progress("Calculating BT-referenced vertical velocities\n");
	calc_BTprof($firstGoodEns,$lastGoodEns,$water_depth,$sig_water_depth);

	my($sumSq) = my($n) = 0;
	for (my($bi)=0; $bi<=$#{$BT{MEDIAN_W}}; $bi++) {
		next unless defined($BT{MEDIAN_W}[$bi]);
		next unless ($BT{N_SAMP}[$bi]>=$opt_k && $DNCAST{N_SAMP}[$bi]>=$opt_k && $UPCAST{N_SAMP}[$bi]>=$opt_k);
		$sumSq += ($BT{MEDIAN_W}[$bi] - $DNCAST{MEDIAN_W}[$bi]/2 - $UPCAST{MEDIAN_W}[$bi]/2)**2;
		$n++;
	}
	if ($n > 0) {
		my($rms) = round(sqrt($sumSq/$n),0.001);
		&antsAddParams('BT_rms_w_discrepancy',$rms);
		progress("\t$rms m/s rms vertical-velocity discrepancy\n");
	}
}

#------------
# full output
#------------

# NB: residual field is calculated with respect to down-/upcast medians in -o-size bins

progress("Writing data...\n");

@antsNewLayout = ('ensemble','bin','elapsed','depth','CTD_depth','downcast',
				  'w','residual','CTD_w','LADCP_w','errvel',
				  'pitch','roll','tilt','heading','3_beam','svel');

for ($ens=$firstGoodEns; $ens<$LADCP_atbottom; $ens++) {						# downcast
	next unless numberp($LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH});
	my(@bindepth) = calc_binDepths($ens);
	for ($bin=$LADCP_firstBin-1; $bin<=$LADCP_lastBin-1; $bin++) {
		next unless numberp($LADCP{ENSEMBLE}[$ens]->{W}[$bin]);
		my($bi) = $bindepth[$bin]/$opt_o;
		&antsOut(
			$ens,$bin,$CTD{ELAPSED}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
			$bindepth[$bin],$LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH},1,
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin],
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin] - $DNCAST{MEDIAN_W}[$bi],
			$CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_W}[$bin],
			$LADCP{ENSEMBLE}[$ens]->{ERRVEL}[$bin],
			$LADCP{ENSEMBLE}[$ens]->{PITCH},
			$LADCP{ENSEMBLE}[$ens]->{ROLL},
			$LADCP{ENSEMBLE}[$ens]->{TILT},
			$LADCP{ENSEMBLE}[$ens]->{HEADING},
			(defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][0]) + 			# only works for beam coords
			 defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][1]) +
			 defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][2]) +
			 defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][3])) < 4 ? 1 : 0,
			$CTD{SVEL}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
		);
	}
}

for ($ens=$LADCP_atbottom; $ens<=$lastGoodEns; $ens++) {						# upcast 
	next unless numberp($LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH});
	my(@bindepth) = calc_binDepths($ens);
	for ($bin=$LADCP_firstBin-1; $bin<=$LADCP_lastBin-1; $bin++) {
		next unless numberp($LADCP{ENSEMBLE}[$ens]->{W}[$bin]);
		my($bi) = $bindepth[$bin]/$opt_o;
		&antsOut(
			$ens,$bin,$CTD{ELAPSED}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
			$bindepth[$bin],$LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH},0,
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin],
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_OCEAN_W}[$bin] - $UPCAST{MEDIAN_W}[$bi],
			$CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
			$LADCP{ENSEMBLE}[$ens]->{SSCORRECTED_W}[$bin],
			$LADCP{ENSEMBLE}[$ens]->{ERRVEL}[$bin],
			$LADCP{ENSEMBLE}[$ens]->{PITCH},
			$LADCP{ENSEMBLE}[$ens]->{ROLL},
			$LADCP{ENSEMBLE}[$ens]->{TILT},
			$LADCP{ENSEMBLE}[$ens]->{HEADING},
			(defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][0]) + 			# only works for beam coords
			 defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][1]) +
			 defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][2]) +
			 defined($LADCP{ENSEMBLE}[$ens]->{VELOCITY}[$bin][3])) < 4 ? 1 : 0,
			$CTD{SVEL}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
		);
	}
}
	
#---------------
# Output profile
#---------------

if (defined($opt_p)) {
	progress("Writing vertical-velocity profiles to <$opt_p>...\n");

	@antsNewLayout = ('depth','dc_depth','dc_elapsed','dc_w','dc_w.mad','dc_w.N',
							  'uc_depth','uc_elapsed','uc_w','uc_w.mad','uc_w.N',
							  'elapsed','w','w.mad','w.N',
	                          'BT_w','BT_w.mad','BT_w.N');

	&antsOut('EOF');
	
	close(STDOUT);
	open(STDOUT,">$opt_p") || croak("$opt_p: $!\n");

	for (my($bi)=0; $bi<=max($#{$DNCAST{ENSEMBLE}},$#{$UPCAST{ENSEMBLE}},$#{$BT{NSAMP}}); $bi++) {
		&antsOut(($bi+0.5)*$opt_o,					# nominal depth
				 $DNCAST{MEAN_DEPTH}[$bi],$DNCAST{MEAN_ELAPSED}[$bi],
				 $DNCAST{N_SAMP}[$bi]>=$opt_k?$DNCAST{MEDIAN_W}[$bi]:nan,
				 $DNCAST{MAD_W}[$bi],$DNCAST{N_SAMP}[$bi],
				 $UPCAST{MEAN_DEPTH}[$bi],$UPCAST{MEAN_ELAPSED}[$bi],
				 $UPCAST{N_SAMP}[$bi]>=$opt_k?$UPCAST{MEDIAN_W}[$bi]:nan,
				 $UPCAST{MAD_W}[$bi],$UPCAST{N_SAMP}[$bi],
				 $DNCAST{MEAN_ELAPSED}[$bi]/2+$UPCAST{MEAN_ELAPSED}[$bi]/2,
				 $DNCAST{N_SAMP}[$bi]+$UPCAST{N_SAMP}[$bi]>=$opt_k ?
					($DNCAST{MEDIAN_W}[$bi]*$DNCAST{N_SAMP}[$bi]+$UPCAST{MEDIAN_W}[$bi]*$UPCAST{N_SAMP}[$bi]) / ($DNCAST{N_SAMP}[$bi]+$UPCAST{N_SAMP}[$bi]) :
					nan,
				 $DNCAST{N_SAMP}[$bi]+$UPCAST{N_SAMP}[$bi]>=$opt_k ?
					 ($DNCAST{MAD_W}[$bi]*$DNCAST{N_SAMP}[$bi]+$UPCAST{MAD_W}[$bi]*$UPCAST{N_SAMP}[$bi]) / ($DNCAST{N_SAMP}[$bi]+$UPCAST{N_SAMP}[$bi]) :
					 nan,
				 $DNCAST{N_SAMP}[$bi]+$UPCAST{N_SAMP}[$bi],
				 $BT{N_SAMP}[$bi]>=$opt_k?$BT{MEDIAN_W}[$bi]:nan,
				 $BT{MAD_W}[$bi],$BT{N_SAMP}[$bi]
		);
	}
}

#--------------------------------------
# write time-series output if requested
#--------------------------------------

if (defined($opt_f)) {
	progress("Writing time-series data to <$opt_f>...\n");

	@antsNewLayout = ('ens','elapsed',
					  'depth','xducer_sound_speed','pitch','gimbal_pitch','roll','tilt','heading',
					  'CTD_w','LADCP_reflr_w','LADCP_reflr_w_err','LADCP_reflr_w_nosscorr',
					  'reflr_ocean_w');
	&antsOut('EOF');

	close(STDOUT);
	open(STDOUT,">$opt_f") || croak("$opt_f: $!\n");
	 
	for ($ens=$firstGoodEns; $ens<=$lastGoodEns; $ens++) {
		my($reflr_oc_w) = defined($LADCP{ENSEMBLE}[$ens]->{REFLR_W})
			   		    ? $LADCP{ENSEMBLE}[$ens]->{REFLR_W} - $CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}]
			   		    : undef;
		&antsOut($ens,										
				 $CTD{ELAPSED}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],	
				 $LADCP{ENSEMBLE}[$ens]->{CTD_DEPTH},
				 $CTD{SVEL}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
				 $LADCP{ENSEMBLE}[$ens]->{PITCH},
				 $LADCP{ENSEMBLE}[$ens]->{GIMBAL_PITCH},
				 $LADCP{ENSEMBLE}[$ens]->{ROLL},
				 $LADCP{ENSEMBLE}[$ens]->{TILT},
				 $LADCP{ENSEMBLE}[$ens]->{HEADING},
				 $CTD{W}[$LADCP{ENSEMBLE}[$ens]->{CTD_SCAN}],
				 $LADCP{ENSEMBLE}[$ens]->{REFLR_W},
				 $LADCP{ENSEMBLE}[$ens]->{REFLR_W_ERR},
				 $LADCP{ENSEMBLE}[$ens]->{REFLR_W_NOSSCORR},
				 $reflr_w);
	}

	close(STDOUT);
	undef($antsHeadersPrinted);
}

&antsExit();
